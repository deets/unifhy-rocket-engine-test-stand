con
  #0, SYSTEM_IDLE, SYSTEM_CAPTURING, SYSTEM_ERROR
  #0, SD_OK, SD_WRITING, SD_ERROR

var
  byte cog, system_status, sd_status
  long stack[1000]
  long count, capacity
obj
  conf: "configuration"
  util: "util"

pub start(capacity_)
  capacity := capacity_
  system_status := SYSTEM_IDLE
  sd_status := SD_OK
  pinstart(conf.CAPTURE_SWITCH, P_NORMAL | P_LOW_15K, 0, 0)
  cog := cogspin(NEWCOG, main(), @stack)

pub sample_written()
  count += 1

pub set_system_idle()
  set_system_state(SYSTEM_IDLE)

pub set_system_capturing()
  set_system_state(SYSTEM_CAPTURING)

pub set_system_error()
  set_system_state(SYSTEM_ERROR)

pub set_sd_state(state)
  sd_status := state

pub set_sd_ok()
  sd_status := SD_OK

pub set_sd_writing()
  sd_status := SD_WRITING

pub set_sd_error()
  sd_status := SD_ERROR

pub should_capture() : result
  if system_status == SYSTEM_IDLE
    return pin_asserted()
  DEBUG(UDEC(count), UDEC(capacity))
  return pin_asserted() and count < capacity

pri pin_asserted() : result
  ' Active High
  return pinread(conf.CAPTURE_SWITCH)

pri set_system_state(state)
  if state == SYSTEM_IDLE and system_status <> SYSTEM_IDLE
    ' we first have to wait until the user
    ' flips back the switch before we go into
    ' IDLE
    repeat until not pin_asserted()
    ' debunce the switch
    waitms(100)
  system_status := state
  ' reset count when we switch to capturing mode
  if state == SYSTEM_CAPTURING
    count := 0

pri main()
  repeat
    case system_status
      SYSTEM_IDLE: pinlow(conf.SYSTEM_STATUS_PIN)
      SYSTEM_CAPTURING: pinhigh(conf.SYSTEM_STATUS_PIN)
      SYSTEM_ERROR: pintoggle(conf.SYSTEM_STATUS_PIN)
    case sd_status
      SD_OK: pinlow(conf.SD_STATUS_PIN)
      SD_WRITING: pinhigh(conf.SD_STATUS_PIN)
      SD_ERROR: pintoggle(conf.SD_STATUS_PIN)
    waitms(100)
