con
  _clkfreq = 300_000_000

  DEBUG_BAUD  = 2_000_000

  BUFFER_SIZE = 65536
  INPUT_BUFFER_SIZE = 256

var
  BYTE buffer[BUFFER_SIZE]
  BYTE read_block_buffer[512]
  LONG input_position
  BYTE input_buffer[INPUT_BUFFER_SIZE]
  BYTE arg1[INPUT_BUFFER_SIZE]
  BYTE arg2[INPUT_BUFFER_SIZE]
  BYTE echo, verify

obj
  sd: "deets_sd_spi"
  util: "util"
  serial: "jm_fullduplexserial"
  conf: "configuration"

pub main(): result | td, max_td, cmd
  echo := 0
  verify := 0
  serial.start(conf.RX0, conf.TX0, %0000, conf.BR_SERIAL)
  banner()
  sd.start_explicit(conf.SD_DO, conf.SD_CLK, conf.SD_DI, conf.SD_CS, conf.SD_SPI_SPEED)
  result := sd.mount_card()
  if result <> 2
    serial.fstr1(string("Unknown card: %d - can't mount!\r\n"), result)
    repeat
  mainloop()


pri mainloop() | cmd
  repeat
    reset_input_buffer()
    cmd := prompt(verify ? "V" : "-")
    case cmd
      0 :
      "e": toggle_echo()
      "v": toggle_verify()
      "d": dump()
      "h": help()
      "f": fill()
      "w": write_test(1)
      "W": write_test(0)
      other: unknown(cmd)


pri help()
  serial.fstr0(@"Command help:\r\n")
  serial.fstr0(@"\r\n")
  serial.fstr0(@"h          - This message.\r\n")
  serial.fstr0(@"d <number> - Dump contents of block/sector <number>.\r\n")
  serial.fstr0(@"             If <number> is X, dump our write buffer.\r\n")
  serial.fstr0(@"d <number> - Dump contents of block/sector <number>.\r\n")
  serial.fstr0(@"f <text>   - Fill the 64KB write buffer with this fragment.\r\n")
  serial.fstr0(@"             Repeat until full.\r\n")
  serial.fstr0(@"v          - Verify mode (read back after write) on.\r\n")
  serial.fstr0(@"w <s> <l>  - Write test, single block. Arguments see below.\r\n")
  serial.fstr0(@"W <s> <l>  - Write test, multiple block. Arguments see below.\r\n")
  nl()
  serial.fstr0(@"             Both tests write the write buffer from block <s>.\r\n")
  serial.fstr0(@"             for <l> blocks.\r\n")
  serial.fstr0(@"             They print out the MBit/seconds this took.\r\n")
  serial.fstr0(@"             If verify mode (V>-prompt) is on, the data is.\r\n")
  serial.fstr0(@"             read back and verified against the write buffer.\r\n")


pri write_test(single_block) | start, length, buffer_pos, ts, elapsed, usdiv, ms, to_write, verify_start
  if not numer_of_args() == 2
    serial.fstr0(@"write test takes two arguments, <s> and <l>\r\n")
    return
  get_arg(@arg1)
  start := toint(@arg1)
  verify_start := start
  get_arg(@arg1)
  length := toint(@arg1)
  serial.fstr3(@"Writing %s from block %d, length: %d\r\n", single_block ? @"single" : @"multiple", start, length)
  buffer_pos := 0
  elapsed := 0
  usdiv := clkfreq / 1_000_000

  if single_block
    repeat length
      ts := cnt()
      sd.write_block(start++, @buffer + buffer_pos)
      elapsed += util.timediff(ts, cnt()) / usdiv
      buffer_pos := (buffer_pos + 512) +// BUFFER_SIZE
  else
    to_write := length
    repeat until to_write == 0
      if to_write >= BUFFER_SIZE / 512
        ts := cnt()
        sd.write_blocks(start, @buffer, BUFFER_SIZE / 512)
        elapsed += util.timediff(ts, cnt()) / usdiv
        start += BUFFER_SIZE / 512
        to_write -= BUFFER_SIZE / 512
      else
        ts := cnt()
        sd.write_blocks(start, @buffer, to_write)
        elapsed += util.timediff(ts, cnt()) / usdiv
        to_write := 0

  ms := elapsed / 1000
  serial.fstr3(@"Wrote %d bytes in %dus, %dms\r\n", length * 512, elapsed, ms)
  if verify
    verify_blockdata(verify_start, length)


pri verify_blockdata(start, length) | buffer_offset, differ, offset
  buffer_offset := 0
  repeat length
    read_block(start++)
    differ, offset := block_and_buffer_differ(@buffer + buffer_offset)
    if differ == 1
      serial.fstr2(@"Verification failed at %d, buffer_offset: %d\r\n", --start, buffer_offset + offset)
      return
    buffer_offset := (buffer_offset + 512) +// BUFFER_SIZE


pri block_and_buffer_differ(buffer_address): result | i
  repeat i from 0 to 511
    if BYTE[buffer_address][i] <> read_block_buffer[i]
      return 1, i
  return 0, 0


pri fill() | offset, size
  if not numer_of_args() == 1
    serial.fstr0(@"fill takes one argument, <pattern>\r\n")
    return

  offset := 0
  if get_arg(@arg1) > 0
    size := strsize(@arg1)
    repeat
      repeat size
        buffer[offset] := arg1[offset +// size]
        ++offset
        if offset == BUFFER_SIZE
          quit
      if offset == BUFFER_SIZE
        quit


pri dump() | err, block_number, nargs, count
  nargs := numer_of_args()
  if nargs < 1 or nargs > 2
    serial.fstr0(@"dump takes arguments, <blocknumber> [<count>]\r\n")
    return
  ' we do have a block number!
  get_arg(@arg1)
  if nargs == 2
    get_arg(@arg2)
    count := toint(@arg2)
  else
    count := (BUFFER_SIZE / 512) - 1
  if util.uppercase(arg1[0]) == "X"
    repeat block_number from 0 to count - 1
      dump_block(@buffer + block_number * 512)
  else
    block_number := toint(@arg1)
    if nargs == 1
      count := 1
    serial.fstr1(@"dumping block %d\r\n", block_number)
    repeat count
      read_block(block_number++)
      dump_block(@read_block_buffer)


pri numer_of_args(): result
  result := 0
  ' we insist on a space
  ' between the command an the first argument
  input_position := 1
  if skip_space() > 0
    repeat until skip_not_space_or_null() == 0
      result++
      input_position := (input_position + 1) +// INPUT_BUFFER_SIZE
  ' reset the input_position here for possible
  ' get_arg calls.
  input_position := 2
  return result


pri write_block(): td | earlier, later
    serial.fstr0(string("write_block\r\n"))
    bytefill(@buffer, 123, BUFFER_SIZE)
    toggle_debug()
    earlier := getct()
    sd.write_block(1234, @buffer)
    later := getct()
    td := util.timediff(earlier, later)
    return td


pri write_blocks(): td | earlier, later
    serial.fstr0(string("write_blocks\r\n"))
    bytefill(@buffer, 123, 512)
    bytefill(@buffer + 512, $aa, 512)
    toggle_debug()
    earlier := getct()
    sd.write_blocks(4567, @buffer, 2)
    later := getct()
    td := util.timediff(earlier, later)
    return td


pri read_block(number): td | earlier, later
    sd.read_block(number, @read_block_buffer)


pri toggle_debug()
    pinlow(conf.DEBUG_PIN)
    waitms(10)
    pinhigh(conf.DEBUG_PIN)
    waitms(10)
    pinlow(conf.DEBUG_PIN)


pri nl()
  serial.tx(13)
  serial.tx(10)


pri reset_input_buffer()
    input_position := 0
    bytefill(@input_buffer, 0, INPUT_BUFFER_SIZE)


pri toint(buf): result | i, c
  i := 0
  result := 0

  c := BYTE[buf][i++]
  repeat until c == 0
    result *= 10
    if util.isnumeric(c)
      result += c - "0"
    else
      quit
    c := BYTE[buf][i++]

  return result


pri toggle_echo()
  echo := not echo
  serial.fstr0(@"ascii echo ")
  if echo
    serial.fstr0(@"on")
  else
    serial.fstr0(@"off")
  nl()


pri toggle_verify()
  verify := not verify


pri prompt(mode) : result | char
  ' Will fill the input_buffer with characters
  ' until <return> is pressed. Will place a trailing
  ' 0 into the buffer.
  ' Returns the first character for quick command
  ' dispatch.
  '
  ' ATTENTION: just wraps around if you type more than
  ' INPUT_BUFFER_SIZE!
  serial.tx(mode)
  serial.tx(">")
  serial.tx(" ")
  result := 0
  repeat
    char := serial.rxcheck()
    if char <> -1
      if echo
        serial.dec(char)
      ' produce echo
      if char <> 13  ' CR
        serial.tx(char)
        input_buffer[input_position] := char
        input_position := (input_position + 1) +// INPUT_BUFFER_SIZE
      else
        nl()
        input_buffer[input_position] := 0
        input_position := (input_position + 1) +// INPUT_BUFFER_SIZE
        return input_buffer[0]


pri unknown(cmd)
  serial.fstr0(@"unknown command\r\n")


pri skip_space() : result
  ' skip spaces in the input buffer and return the amount
  result := 0
  repeat while result + input_position < INPUT_BUFFER_SIZE and input_buffer[result + input_position] == " "
    ++result
  input_position += result
  return result


pri skip_not_space_or_null() : result | c
  ' skip anything that's not a space/0
  result := 0
  repeat
    if result + input_position >= INPUT_BUFFER_SIZE
      quit
    c := input_buffer[result + input_position]
    if c <> " " and c <> 0
      ++result
    else
      quit

  input_position += result
  return result


pri get_arg(buf) : i | c
  i := 0
  repeat while input_position < INPUT_BUFFER_SIZE
    c := input_buffer[input_position]
    if c <> " " and c <> 0
      ' This bit me in the ass. Using normal
      ' assignment would result in LONGs being
      ' written. Only through the BYTE redirection
      ' this works. Which makes sense.
      BYTE[buf][i++] := c
      ++input_position
    else
      quit
  ' same here... doh!
  BYTE[buf][i] := 0 ' terminating 0
  ' place input_position on the next agument
  skip_space()
  return i


pri error()
  serial.fstr0(@"error\r\n")


pri dump_block(buf) | offset, copy, c
  offset := 0
  repeat 32
    copy := offset
    repeat 16
      serial.fhex(BYTE[buf][offset++], 2)
    serial.tx(" ")
    repeat 16
      c := BYTE[buf][copy++]
      if util.isalpha(c) or util.isnumeric(c)
        serial.tx(c)
      else
        serial.tx(".")
    nl()
  nl()


pri banner()
  serial.fstr0(@"#######################################################\r\n#                                                     #\r\n# SD Card Throughput Test - (C) 2022 Diez B. Roggisch #\r\n#                                                     #\r\n#   Press h <enter> for help                          #\r\n#                                                     #\r\n#######################################################\r\n")
  nl()
