con
  _clkfreq = 300_000_000

  DEBUG_BAUD  = 2_000_000

  BUFFER_SIZE = 65536
  INPUT_BUFFER_SIZE = 256

var
  BYTE buffer[BUFFER_SIZE]
  BYTE read_block_buffer[512]
  LONG input_position
  BYTE input_buffer[INPUT_BUFFER_SIZE]
  BYTE arg1[INPUT_BUFFER_SIZE]
  BYTE echo

obj
  sd: "deets_sd_spi"
  util: "util"
  serial: "jm_fullduplexserial"
  conf: "configuration"

pub main(): result | td, max_td, cmd
  serial.start(conf.RX0, conf.TX0, %0000, conf.BR_SERIAL)
  banner()
  sd.start_explicit(conf.SD_DO, conf.SD_CLK, conf.SD_DI, conf.SD_CS, conf.SD_SPI_SPEED)
  result := sd.mount_card()
  if result <> 2
    serial.fstr1(string("Unknown card: %d - can't mount!\r\n"), result)
    repeat
  mainloop()


pri mainloop() | cmd
  repeat
    reset_input_buffer()
    cmd := prompt()
    case cmd
      0 :
      "e": toggle_echo()
      "d": dump()
      "h": help()
      "f": fill()
      other: unknown(cmd)


pri help()
  serial.fstr0(@"Command help:\r\n")
  serial.fstr0(@"\r\n")
  serial.fstr0(@"h          - This message.\r\n")
  serial.fstr0(@"d <number> - Dump contents of block/sector <number>.\r\n")
  serial.fstr0(@"             If <number> is X, dump our write buffer.\r\n")
  serial.fstr0(@"d <number> - Dump contents of block/sector <number>.\r\n")
  serial.fstr0(@"f <text>   - Fill the 64KB write buffer with this fragment.\r\n")
  serial.fstr0(@"             Repeat until full.\r\n")
  serial.fstr0(@"v          - Verify mode (read back after write) on.\r\n")


pri fill() | offset, size
  if not numer_of_args() == 1
    serial.fstr0(@"fill takes one argument, <blocknumber>\r\n")
    return

  offset := 0
  if get_arg(@arg1) > 0
    size := strsize(@arg1)
    serial.fstr1(@"arg size: %d\r\n", size)
    repeat
      repeat size
        buffer[offset] := arg1[offset +// size]
        ++offset
        if offset == BUFFER_SIZE
          quit
      if offset == BUFFER_SIZE
        quit


pri dump() | err, block_number
  if not numer_of_args() == 1
    serial.fstr0(@"dump takes one argument, <blocknumber>\r\n")
    return
  ' we do have a block number!
  if get_arg(@arg1) > 0
    if arg1[0] == "X"
      repeat block_number from 0 to (BUFFER_SIZE / 512) - 1
        dump_block(@buffer + block_number * 512)
    else
      block_number := toint(@arg1)
      serial.fstr1(@"dumping block %d\r\n", block_number)
      read_block(block_number)
      dump_block(@read_block_buffer)


pri numer_of_args(): result
  result := 0
  ' we insist on a space
  ' between the command an the first argument
  input_position := 1
  if skip_space() > 0
    repeat until skip_not_space_or_null() == 0
      result++
      input_position := (input_position + 1) +// INPUT_BUFFER_SIZE
  ' reset the input_position here for possible
  ' get_arg calls.
  input_position := 2
  return result


pri write_block(): td | earlier, later
    serial.fstr0(string("write_block\r\n"))
    bytefill(@buffer, 123, BUFFER_SIZE)
    toggle_debug()
    earlier := getct()
    sd.write_block(1234, @buffer)
    later := getct()
    td := util.timediff(earlier, later)
    return td


pri write_blocks(): td | earlier, later
    serial.fstr0(string("write_blocks\r\n"))
    bytefill(@buffer, 123, 512)
    bytefill(@buffer + 512, $aa, 512)
    toggle_debug()
    earlier := getct()
    sd.write_blocks(4567, @buffer, 2)
    later := getct()
    td := util.timediff(earlier, later)
    return td


pri read_block(number): td | earlier, later
    sd.read_block(number, @read_block_buffer)


pri toggle_debug()
    pinlow(conf.DEBUG_PIN)
    waitms(10)
    pinhigh(conf.DEBUG_PIN)
    waitms(10)
    pinlow(conf.DEBUG_PIN)


pri nl()
  serial.tx(13)
  serial.tx(10)


pri reset_input_buffer()
    input_position := 0
    bytefill(@input_buffer, 0, INPUT_BUFFER_SIZE)


pri toint(buf): result | i, c
  i := 0
  result := 0

  c := BYTE[buf][i++]
  repeat until c == 0
    result *= 10
    if util.isnumeric(c)
      result += c - "0"
    else
      quit
    c := BYTE[buf][i++]

  return result


pri toggle_echo()
  echo := not echo
  serial.fstr0(@"ascii echo ")
  if echo
    serial.fstr0(@"on")
  else
    serial.fstr0(@"off")
  nl()


pri prompt() : result | char
  ' Will fill the input_buffer with characters
  ' until <return> is pressed. Will place a trailing
  ' 0 into the buffer.
  ' Returns the first character for quick command
  ' dispatch.
  '
  ' ATTENTION: just wraps around if you type more than
  ' INPUT_BUFFER_SIZE!
  serial.tx(">")
  serial.tx(" ")
  result := 0
  repeat
    char := serial.rxcheck()
    if char <> -1
      if echo
        serial.dec(char)
      ' produce echo
      if char <> 13  ' CR
        serial.tx(char)
        input_buffer[input_position] := char
        input_position := (input_position + 1) +// INPUT_BUFFER_SIZE
      else
        nl()
        input_buffer[input_position] := 0
        input_position := (input_position + 1) +// INPUT_BUFFER_SIZE
        return input_buffer[0]


pri unknown(cmd)
  serial.fstr0(@"unknown command\r\n")


pri skip_space() : result
  ' skip spaces in the input buffer and return the amount
  result := 0
  repeat while result + input_position < INPUT_BUFFER_SIZE and input_buffer[result + input_position] == " "
    ++result
  input_position += result
  return result


pri skip_not_space_or_null() : result | c
  ' skip anything that's not a space/0
  result := 0
  repeat
    if result + input_position >= INPUT_BUFFER_SIZE
      quit
    c := input_buffer[result + input_position]
    if c <> " " and c <> 0
      ++result
    else
      quit

  input_position += result
  return result


pri get_arg(buf) : i | c
  i := 0
  repeat while input_position < INPUT_BUFFER_SIZE
    c := input_buffer[input_position]
    if c <> " " and c <> 0
      ' This bit me in the ass. Using normal
      ' assignment would result in LONGs being
      ' written. Only through the BYTE redirection
      ' this works. Which makes sense.
      BYTE[buf][i++] := c
      ++input_position
    else
      quit
  buf[i] := 0 ' terminating 0
  return i


pri error()
  serial.fstr0(@"error\r\n")


pri dump_block(buf) | offset, copy, c
  offset := 0
  repeat 32
    copy := offset
    repeat 16
      serial.fhex(BYTE[buf][offset++], 2)
    serial.tx(" ")
    repeat 16
      c := BYTE[buf][copy++]
      if util.isalpha(c) or util.isnumeric(c)
        serial.tx(c)
      else
        serial.tx(".")
    nl()
  nl()


pri banner()
  serial.fstr0(@"#######################################################\r\n#                                                     #\r\n# SD Card Throughput Test - (C) 2022 Diez B. Roggisch #\r\n#                                                     #\r\n#   Press h <enter> for help                          #\r\n#                                                     #\r\n#######################################################\r\n")
  nl()
